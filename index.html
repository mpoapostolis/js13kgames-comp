<!DOCTYPE html>
<html lang="el">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dungeon Escape ‚Äî Enhanced RPG</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        background: linear-gradient(135deg, #0a0e27 0%, #151933 100%);
        color: #fff;
        font-family: "Orbitron", monospace;
        overflow: hidden;
        user-select: none;
      }

      canvas {
        display: block;
        cursor: crosshair;
      }

      /* HUD */
      #hud {
        position: fixed;
        left: 20px;
        top: 20px;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(10, 10, 30, 0.7));
        padding: 15px 20px;
        border-radius: 15px;
        border: 2px solid rgba(100, 200, 255, 0.3);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        animation: hudGlow 3s ease-in-out infinite;
      }

      @keyframes hudGlow {
        0%,
        100% {
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        50% {
          box-shadow: 0 8px 32px rgba(0, 100, 200, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
      }

      #hud .stat {
        display: flex;
        align-items: center;
        margin: 8px 0;
        font-size: 14px;
        font-weight: 700;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }

      #hud .icon {
        width: 24px;
        height: 24px;
        margin-right: 10px;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
      }

      .health-bar {
        width: 150px;
        height: 20px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .health-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff3366, #ff6b6b);
        transition: width 0.3s ease;
        box-shadow: 0 0 10px rgba(255, 50, 100, 0.5);
      }

      #controls {
        position: fixed;
        left: 20px;
        bottom: 20px;
        background: rgba(0, 0, 0, 0.6);
        padding: 12px 16px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        font-size: 11px;
        opacity: 0.8;
      }

      #controls span {
        color: #64d4ff;
        font-weight: 700;
      }

      /* Score & Wave */
      #score {
        position: fixed;
        right: 20px;
        top: 20px;
        background: linear-gradient(135deg, rgba(255, 100, 0, 0.2), rgba(255, 0, 100, 0.2));
        padding: 15px 25px;
        border-radius: 15px;
        border: 2px solid rgba(255, 150, 50, 0.4);
        font-size: 18px;
        font-weight: 900;
        text-align: center;
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      #score .value {
        font-size: 28px;
        color: #ffd700;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      }

      /* Messages */
      #msg {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        z-index: 1000;
      }

      #msg .card {
        background: linear-gradient(135deg, #1a1f3a, #2a3f5f);
        padding: 30px 40px;
        border-radius: 20px;
        border: 2px solid rgba(100, 200, 255, 0.3);
        text-align: center;
        max-width: 500px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        animation: slideIn 0.5s ease-out;
      }

      @keyframes slideIn {
        from {
          transform: translateY(-50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      #msg h1 {
        margin: 0 0 15px;
        font-size: 32px;
        background: linear-gradient(90deg, #64d4ff, #ff6b6b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 30px rgba(100, 200, 255, 0.5);
      }

      #msg p {
        margin: 10px 0;
        opacity: 0.9;
        line-height: 1.6;
      }

      .btn {
        margin-top: 20px;
        padding: 12px 30px;
        border-radius: 25px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        font-weight: 700;
        cursor: pointer;
        font-family: "Orbitron", monospace;
        font-size: 16px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
      }

      /* Damage flash */
      .damage-flash {
        position: fixed;
        inset: 0;
        background: radial-gradient(circle, transparent, rgba(255, 0, 0, 0.3));
        pointer-events: none;
        animation: flash 0.3s ease-out;
        z-index: 100;
      }

      @keyframes flash {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }

      /* Combat text */
      .combat-text {
        position: fixed;
        font-weight: 900;
        font-size: 24px;
        pointer-events: none;
        z-index: 500;
        animation: floatUp 1s ease-out forwards;
      }

      @keyframes floatUp {
        0% {
          transform: translateY(0);
          opacity: 1;
        }
        100% {
          transform: translateY(-50px);
          opacity: 0;
        }
      }

      /* Power-ups */
      #powerup {
        position: fixed;
        left: 50%;
        top: 100px;
        transform: translateX(-50%);
        background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 100, 0, 0.2));
        padding: 10px 20px;
        border-radius: 20px;
        border: 2px solid rgba(255, 215, 0, 0.5);
        font-weight: 700;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      #powerup.show {
        opacity: 1;
        animation: powerupPulse 0.5s ease-out;
      }

      @keyframes powerupPulse {
        0% {
          transform: translateX(-50%) scale(0.5);
        }
        50% {
          transform: translateX(-50%) scale(1.2);
        }
        100% {
          transform: translateX(-50%) scale(1);
        }
      }

      /* FPS Counter */
      #fps {
        position: fixed;
        right: 20px;
        bottom: 20px;
        background: rgba(0, 0, 0, 0.5);
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 12px;
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <!-- HUD -->
    <div id="hud">
      <div class="stat">
        <span class="icon">‚ù§Ô∏è</span>
        <div class="health-bar">
          <div class="health-fill" id="health" style="width: 100%"></div>
        </div>
        <span style="margin-left: 10px" id="healthText">100/100</span>
      </div>
      <div class="stat">
        <span class="icon">‚≠ê</span>
        <span>Keys: <span id="keys">0</span>/3</span>
      </div>
      <div class="stat">
        <span class="icon">üö™</span>
        <span>Exit: <span id="door">Locked</span></span>
      </div>
      <div class="stat">
        <span class="icon">‚öîÔ∏è</span>
        <span>Enemies: <span id="enemies">2</span></span>
      </div>
    </div>

    <!-- Score -->
    <div id="score">
      <div>SCORE</div>
      <div class="value" id="scoreValue">0</div>
      <div style="font-size: 14px; margin-top: 5px">Wave <span id="wave">1</span></div>
    </div>

    <!-- Power-up notification -->
    <div id="powerup"></div>

    <!-- Controls -->
    <div id="controls">
      <span>WASD:</span> Move ‚Ä¢ <span>Shift:</span> Run ‚Ä¢ <span>Click:</span> Attack ‚Ä¢
      <span>Space:</span> Dash ‚Ä¢ <span>Q:</span> Berserker (50 rage) ‚Ä¢ <span>E:</span> Lightning (3
      combo) ‚Ä¢ <span>R:</span> Reset
    </div>

    <!-- FPS -->
    <div id="fps">FPS: <span id="fpsv">0</span></div>

    <!-- Start screen -->
    <div id="msg">
      <div class="card">
        <h1>üè∞ DUNGEON ESCAPE üè∞</h1>
        <p><strong>Survive the dungeon!</strong></p>
        <p>
          Collect all 3 keys to unlock the exit door.<br />
          Defeat enemies to gain score and health.<br />
          Click to attack, Space to dash away from danger!
        </p>
        <button class="btn" id="start">START GAME</button>
      </div>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.158.0/build/three.module.js";
      import * as Tone from "https://cdn.skypack.dev/tone@14.7.77";

      console.log("Script loaded!");

      // === Game State ===
      const gameState = {
        health: 100,
        maxHealth: 100,
        score: 0,
        wave: 1,
        keysCollected: 0,
        doorOpen: false,
        enemiesKilled: 0,
        dashCooldown: 0,
        attackCooldown: 0,
        invulnerable: 0,
        powerups: [],
        combo: 0,
        comboTimer: 0,
        rage: 0,
        maxRage: 100,
        timeSlowActive: false,
        earthquakeActive: false,
      };

      // === Audio System ===
      const audio = {
        synth: null,
        bass: null,
        drums: null,
        musicLoop: null,

        init() {
          this.synth = new Tone.PolySynth(Tone.Synth).toDestination();
          this.synth.volume.value = -20;

          // Epic orchestral instruments
          this.bass = new Tone.Synth({
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.1, decay: 0.3, sustain: 0.4, release: 1.2 },
          }).toDestination();
          this.bass.volume.value = -12;

          // Lead melody synth (like strings)
          this.lead = new Tone.PolySynth({
            oscillator: { type: "square" },
            envelope: { attack: 0.3, decay: 0.4, sustain: 0.6, release: 1.5 },
          }).toDestination();
          this.lead.volume.value = -18;

          // Pad synth (like choir)
          this.pad = new Tone.PolySynth({
            oscillator: { type: "sine" },
            envelope: { attack: 1, decay: 0.5, sustain: 0.8, release: 2 },
          }).toDestination();
          this.pad.volume.value = -25;

          // Epic drums
          this.drums = new Tone.MembraneSynth().toDestination();
          this.drums.volume.value = -8;

          // High hat / cymbal
          this.hihat = new Tone.MetalSynth().toDestination();
          this.hihat.volume.value = -20;

          this.startMusic();
        },

        startMusic() {
          if (this.musicLoop) this.musicLoop.stop();

          // Gentle lullaby progression
          const gentleChords = [
            ["C4", "E4", "G4"], // C major - peaceful
            ["F3", "A3", "C4"], // F major - warm
            ["G3", "B3", "D4"], // G major - hopeful
            ["C4", "E4", "G4"], // Back to C - home
          ];

          // Simple, beautiful lullaby melody
          const lullabyMelody = [
            "G4",
            "E4",
            "C4",
            "D4",
            "E4",
            "F4",
            "G4",
            "G4",
            "G4",
            "E4",
            "C4",
            "D4",
            "C4",
            "E4",
            "G4",
            "C4",
          ];

          let melodyIndex = 0;
          let beat = 0;

          this.musicLoop = new Tone.Loop(() => {
            const chordIndex = Math.floor(beat / 16) % gentleChords.length;

            // Soft bass every 4 beats
            // if (beat % 8 === 0) {
            //   this.bass.triggerAttackRelease("C2", "2n");
            // }

            // Gentle chord pad
            if (beat % 16 === 0) {
              this.pad.triggerAttackRelease(gentleChords[chordIndex], "1n");
            }

            // Lullaby melody every 2 beats
            if (beat % 4 === 0) {
              const note = lullabyMelody[melodyIndex % lullabyMelody.length];
              this.lead.triggerAttackRelease(note, "2n");
              melodyIndex++;
            }

            beat++;
          }, "2n");

          Tone.Transport.bpm.value = 900; // Slow, peaceful tempo
          this.musicLoop.start();
          Tone.Transport.start();
        },

        playHit() {
          if (this.synth) this.synth.triggerAttackRelease("C2", "32n");
        },
        playPickup() {
          if (this.synth) this.synth.triggerAttackRelease(["E4", "G4", "B4"], "8n");
        },
        playAttack() {
          if (this.synth) this.synth.triggerAttackRelease("F3", "32n");
        },
        playDash() {
          if (this.synth) this.synth.triggerAttackRelease(["A3", "C4"], "16n");
        },
        playEnemyHit() {
          if (this.synth) this.synth.triggerAttackRelease("G2", "32n");
        },
        playWin() {
          if (this.synth) this.synth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "4n");
        },

        playBerserker() {
          // Epic berserker sound
          this.bass.triggerAttackRelease("C1", "2n");
          setTimeout(() => this.synth.triggerAttackRelease(["F4", "A4", "C5"], "4n"), 200);
        },

        playLightning() {
          // Lightning strike sound
          this.synth.triggerAttackRelease(["G5", "C6", "E6"], "8n");
          setTimeout(() => this.drums.triggerAttackRelease("C0", "16n"), 100);
        },

        playEarthquake() {
          // Earthquake rumble
          this.bass.triggerAttackRelease("C0", "1n");
          for (let i = 0; i < 5; i++) {
            setTimeout(() => this.drums.triggerAttackRelease("C1", "32n"), i * 100);
          }
        },
      };

      // === Renderer/Scene/Camera ===
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: "high-performance",
      });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0e27);
      scene.fog = new THREE.FogExp2(0x0a0e27, 0.02);

      const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 200);
      camera.position.set(0, 12, 15);

      // === Post-processing glow effect (simple) ===
      const composer = null; // Would need EffectComposer for real post-processing

      // === Lights ===
      const ambient = new THREE.AmbientLight(0x404060, 0.4);
      scene.add(ambient);

      const hemi = new THREE.HemisphereLight(0x8899ff, 0x223366, 0.6);
      scene.add(hemi);

      const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
      mainLight.position.set(10, 20, 5);
      mainLight.castShadow = true;
      mainLight.shadow.camera.left = -20;
      mainLight.shadow.camera.right = 20;
      mainLight.shadow.camera.top = 20;
      mainLight.shadow.camera.bottom = -20;
      mainLight.shadow.mapSize.width = 2048;
      mainLight.shadow.mapSize.height = 2048;
      scene.add(mainLight);

      // Moving point lights for atmosphere
      const pointLight1 = new THREE.PointLight(0xff6b6b, 0.5, 15);
      pointLight1.position.set(-5, 3, -5);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0x64d4ff, 0.5, 15);
      pointLight2.position.set(5, 3, 5);
      scene.add(pointLight2);

      // === Ground with grid texture ===
      const groundSize = 100;
      const groundGeom = new THREE.PlaneGeometry(groundSize, groundSize, 20, 20);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x1a1f3a,
        roughness: 0.8,
        metalness: 0.2,
        wireframe: false,
      });

      // Add subtle height variation
      const vertices = groundGeom.attributes.position.array;
      for (let i = 2; i < vertices.length; i += 3) {
        vertices[i] = Math.sin(vertices[i - 2] * 0.1) * 0.1 + Math.cos(vertices[i - 1] * 0.1) * 0.1;
      }
      groundGeom.computeVertexNormals();

      const ground = new THREE.Mesh(groundGeom, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid overlay
      const gridHelper = new THREE.GridHelper(groundSize, 50, 0x2a3f5f, 0x1a2538);
      scene.add(gridHelper);

      // === Enhanced Map ===
      const MAP = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1],
        [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1],
        [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1],
        [1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1],
        [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],
        [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1],
        [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1],
        [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
        [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1],
      ];

      const T = 3; // Tile size
      const walls = [];
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0x2a3f5f,
        roughness: 0.7,
        metalness: 0.3,
        emissive: 0x0a0e27,
        emissiveIntensity: 0.1,
      });

      // Create walls with variation
      for (let z = 0; z < MAP.length; z++) {
        for (let x = 0; x < MAP[z].length; x++) {
          if (MAP[z][x] === 1) {
            const height = 3 + Math.random() * 0.5;
            const wallGeom = new THREE.BoxGeometry(T, height, T);
            const wall = new THREE.Mesh(wallGeom, wallMat);
            wall.position.set((x - MAP[0].length / 2) * T, height / 2, (z - MAP.length / 2) * T);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
          }
        }
      }

      // === Door ===
      const doorGroup = new THREE.Group();
      const doorGeom = new THREE.BoxGeometry(T, 3.5, 0.3);
      const doorMat = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        emissive: 0xff4400,
        emissiveIntensity: 0,
        roughness: 0.3,
        metalness: 0.7,
      });
      const doorMesh = new THREE.Mesh(doorGeom, doorMat);
      doorMesh.castShadow = true;
      doorGroup.add(doorMesh);

      // Door frame
      const frameGeom = new THREE.BoxGeometry(T + 0.4, 3.8, 0.2);
      const frameMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, metalness: 0.8 });
      const frame = new THREE.Mesh(frameGeom, frameMat);
      frame.position.z = 0.1;
      doorGroup.add(frame);

      scene.add(doorGroup);

      // Position door
      for (let z = 0; z < MAP.length; z++) {
        for (let x = 0; x < MAP[z].length; x++) {
          if (MAP[z][x] === 2) {
            doorGroup.position.set((x - MAP[0].length / 2) * T, 1.75, (z - MAP.length / 2) * T);
          }
        }
      }

      // === Player ===
      const playerGroup = new THREE.Group();

      // Player body
      const playerGeom = new THREE.CapsuleGeometry(0.4, 1, 8, 16);
      const playerMat = new THREE.MeshStandardMaterial({
        color: 0x64d4ff,
        emissive: 0x0066ff,
        emissiveIntensity: 0.2,
        roughness: 0.3,
        metalness: 0.5,
      });
      const playerMesh = new THREE.Mesh(playerGeom, playerMat);
      playerMesh.castShadow = true;
      playerGroup.add(playerMesh);

      // Player sword
      const swordGeom = new THREE.BoxGeometry(0.1, 1.5, 0.1);
      const swordMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xaaaaff,
        emissiveIntensity: 0.3,
        metalness: 0.9,
      });
      const sword = new THREE.Mesh(swordGeom, swordMat);
      sword.position.set(0.5, 0.5, 0);
      sword.rotation.z = -0.3;
      playerGroup.add(sword);

      scene.add(playerGroup);
      playerGroup.position.set(0, 1.2, 0); // Center of map, not in wall

      // === Particles ===
      const particles = [];

      // === Keys ===
      const keys = [];
      const keyGroup = new THREE.Group();

      function createKey(x, z) {
        const group = new THREE.Group();

        // Key body
        const keyGeom = new THREE.TorusGeometry(0.3, 0.1, 12, 24);
        const keyMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5,
          metalness: 0.8,
          roughness: 0.2,
        });
        const keyMesh = new THREE.Mesh(keyGeom, keyMat);
        keyMesh.rotation.x = Math.PI / 2;
        group.add(keyMesh);

        // Glow effect
        const glowGeom = new THREE.SphereGeometry(0.6, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({
          color: 0xffdd00,
          transparent: true,
          opacity: 0.2,
        });
        const glow = new THREE.Mesh(glowGeom, glowMat);
        group.add(glow);

        group.position.set(x, 1.5, z);
        group.userData = { keyMesh, glow };
        scene.add(group);
        keys.push(group);
      }

      // More keys scattered across the bigger map
      createKey(-24, 15); // Top left area
      createKey(-12, 6); // Left middle
      createKey(0, -9); // Center bottom
      createKey(18, 12); // Top right
      createKey(15, -3); // Right middle
      createKey(-6, -15); // Bottom left
      createKey(9, -18); // Bottom right

      // === Enemies ===
      const enemies = [];

      class Enemy {
        constructor(x, z, type = "basic") {
          this.type = type;
          this.health = type === "basic" ? 40 : type === "heavy" ? 80 : 250; // Harder enemies
          this.maxHealth = this.health;
          this.speed = type === "basic" ? 2.5 : type === "heavy" ? 2 : 1.2; // Faster enemies
          this.damage = type === "basic" ? 15 : type === "heavy" ? 25 : 35; // More damage
          this.attackCooldown = 0;
          this.specialAttackCooldown = 0;

          // Create mesh
          const group = new THREE.Group();
          const size = type === "basic" ? 0.6 : 0.9;
          const geom =
            type === "basic"
              ? new THREE.OctahedronGeometry(size)
              : new THREE.IcosahedronGeometry(size);
          const mat = new THREE.MeshStandardMaterial({
            color: type === "basic" ? 0xff6b6b : 0xff3366,
            emissive: type === "basic" ? 0xaa0000 : 0xff0000,
            emissiveIntensity: 0.3,
            roughness: 0.4,
            metalness: 0.3,
          });

          this.mesh = new THREE.Mesh(geom, mat);
          this.mesh.castShadow = true;
          group.add(this.mesh);

          // Health bar
          const barBg = new THREE.Mesh(
            new THREE.PlaneGeometry(1, 0.1),
            new THREE.MeshBasicMaterial({ color: 0x333333 }),
          );
          barBg.position.y = 1.2;
          group.add(barBg);

          this.healthBar = new THREE.Mesh(
            new THREE.PlaneGeometry(1, 0.08),
            new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
          );
          this.healthBar.position.y = 1.2;
          this.healthBar.position.z = 0.01;
          group.add(this.healthBar);

          group.position.set(x, 1, z);
          this.group = group;
          this.vel = new THREE.Vector3();
          scene.add(group);
          enemies.push(this);
        }

        update(dt, playerPos) {
          // Face health bar to camera
          this.healthBar.lookAt(camera.position);

          // AI behavior
          const toPlayer = playerPos.clone().sub(this.group.position);
          const dist = toPlayer.length();

          if (dist < 20) {
            // Smarter AI behavior
            if (dist > 8) {
              // Chase when far away
              toPlayer.normalize();
              this.vel.lerp(toPlayer.multiplyScalar(this.speed), 0.1);
            } else if (dist > 3) {
              // Circle strafe when medium distance
              const tangent = new THREE.Vector3(-toPlayer.z, 0, toPlayer.x).normalize();
              const circleDirection = toPlayer.clone().normalize().add(tangent.multiplyScalar(0.5));
              this.vel.lerp(circleDirection.multiplyScalar(this.speed * 1.2), 0.1);
            } else {
              // Aggressive close combat
              toPlayer.normalize();
              this.vel.lerp(toPlayer.multiplyScalar(this.speed * 1.8), 0.1);
            }
            this.group.position.addScaledVector(this.vel, dt);

            // Rotation
            this.mesh.rotation.y = Math.atan2(toPlayer.x, toPlayer.z);

            // Wall collision
            for (const wall of walls) {
              const dx = Math.abs(this.group.position.x - wall.position.x) - (T / 2 + 0.5);
              const dz = Math.abs(this.group.position.z - wall.position.z) - (T / 2 + 0.5);
              if (dx < 0 && dz < 0) {
                this.group.position.addScaledVector(this.vel.clone().multiplyScalar(-1), dt * 2);
              }
            }

            // Attack player
            if (dist < 1.5 && this.attackCooldown <= 0) {
              this.attack();
              this.attackCooldown = this.type === "boss" ? 0.5 : 0.8; // Faster attacks
            }

            // Special boss attacks
            if (this.type === "boss" && this.specialAttackCooldown <= 0) {
              if (dist < 8 && Math.random() < 0.3) {
                this.specialAttack();
                this.specialAttackCooldown = 3;
              }
            }
          }

          // Floating animation
          this.mesh.position.y = Math.sin(Date.now() * 0.003) * 0.1;
          this.mesh.rotation.x += dt * 0.5;

          // Update cooldowns
          this.attackCooldown = Math.max(0, this.attackCooldown - dt);
          this.specialAttackCooldown = Math.max(0, this.specialAttackCooldown - dt);
        }

        attack() {
          if (gameState.invulnerable <= 0) {
            takeDamage(this.damage);
            audio.playHit();
            gameState.combo = Math.max(0, gameState.combo - 2); // Lose combo when hit
            gameState.rage = Math.max(0, gameState.rage - 20); // Lose rage when hit
          }
        }

        specialAttack() {
          // Boss ranged attack
          createParticles(this.group.position, 0xff0000, 20);

          // Create projectile towards player
          const direction = playerGroup.position.clone().sub(this.group.position).normalize();
          const projectile = {
            position: this.group.position.clone(),
            velocity: direction.multiplyScalar(8),
            life: 60,
            damage: 40,
          };

          // Add to projectiles array (we'll create this)
          if (!window.projectiles) window.projectiles = [];
          window.projectiles.push(projectile);

          showPowerup("üí• BOSS ATTACK! üí•");
        }

        takeDamage(amount) {
          this.health -= amount;
          this.healthBar.scale.x = Math.max(0, this.health / this.maxHealth);

          // Flash red
          this.mesh.material.emissiveIntensity = 1;
          setTimeout(() => (this.mesh.material.emissiveIntensity = 0.3), 100);

          if (this.health <= 0) {
            this.die();
          }
        }

        die() {
          // Particle explosion
          createParticles(this.group.position, 0xff6b6b, 20);

          // Score
          gameState.score += this.type === "basic" ? 100 : 250;
          gameState.enemiesKilled++;
          updateUI();

          // Drop health and powerups more often
          if (Math.random() < 0.5) {
            createHealthPack(this.group.position.x, this.group.position.z);
          }

          // Chance for speed powerup
          if (Math.random() < 0.15) {
            createSpeedBoost(this.group.position.x, this.group.position.z);
          }

          // Remove
          scene.remove(this.group);
          enemies.splice(enemies.indexOf(this), 1);

          audio.playEnemyHit();
        }
      }

      // Spawn initial enemies across the bigger map
      new Enemy(-18, 9, "basic");
      new Enemy(-6, 12, "basic");
      new Enemy(12, 6, "heavy");
      new Enemy(6, -12, "basic");
      new Enemy(-12, -6, "basic");
      new Enemy(21, -9, "heavy");
      new Enemy(-21, -12, "basic");
      new Enemy(9, 18, "basic");

      // Spawn massive boss at start
      function spawnBoss() {
        const boss = new Enemy(0, -25, "boss");

        // Override boss stats AFTER creation
        boss.health = 800;
        boss.maxHealth = 800;
        boss.speed = 1.5;
        boss.damage = 40;
        boss.type = "boss"; // Make sure type is set

        // Make boss MASSIVE and purple
        boss.mesh.material.color.setHex(0x8800ff);
        boss.mesh.material.emissive.setHex(0x4400aa);
        boss.mesh.material.emissiveIntensity = 0.8;
        boss.mesh.scale.setScalar(3); // HUGE boss
        boss.group.scale.setScalar(2); // Even bigger
        boss.healthBar.scale.setScalar(2); // Bigger health bar

        // Update health bar to show correct health
        boss.healthBar.scale.x = boss.health / boss.maxHealth;

        createParticles(boss.group.position, 0x8800ff, 50);
        showPowerup("üíÄ MASSIVE BOSS SPAWNED! üíÄ");

        // Add scary boss effects
        scene.fog.density = 0.04;
        pointLight1.color.setHex(0x880088);
        pointLight2.color.setHex(0x440088);

        console.log("Boss spawned with health:", boss.health, "type:", boss.type);
      }

      // Spawn boss immediately
      spawnBoss();

      function createParticles(position, color, count = 10) {
        for (let i = 0; i < count; i++) {
          const geom = new THREE.SphereGeometry(0.1, 8, 8);
          const mat = new THREE.MeshBasicMaterial({
            color,
            transparent: true,
            opacity: 1,
          });
          const particle = new THREE.Mesh(geom, mat);
          particle.position.copy(position);
          particle.userData = {
            velocity: new THREE.Vector3(
              (Math.random() - 0.5) * 5,
              Math.random() * 5,
              (Math.random() - 0.5) * 5,
            ),
            life: 1,
          };
          scene.add(particle);
          particles.push(particle);
        }
      }

      function updateParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.position.add(p.userData.velocity.clone().multiplyScalar(dt));
          p.userData.velocity.y -= 10 * dt; // gravity
          p.userData.life -= dt * 2;
          p.material.opacity = p.userData.life;
          p.scale.setScalar(p.userData.life);

          if (p.userData.life <= 0) {
            scene.remove(p);
            particles.splice(i, 1);
          }
        }
      }

      // === Health Packs ===
      const healthPacks = [];

      function createHealthPack(x, z) {
        const group = new THREE.Group();
        const geom = new THREE.OctahedronGeometry(0.3);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x00ff00,
          emissive: 0x00ff00,
          emissiveIntensity: 0.5,
        });
        const mesh = new THREE.Mesh(geom, mat);
        group.add(mesh);
        group.position.set(x, 1, z);
        group.userData = { mesh, type: "health" };
        scene.add(group);
        healthPacks.push(group);
      }

      function createSpeedBoost(x, z) {
        const group = new THREE.Group();
        const geom = new THREE.ConeGeometry(0.3, 0.8, 6);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x00ffff,
          emissive: 0x0088ff,
          emissiveIntensity: 0.6,
        });
        const mesh = new THREE.Mesh(geom, mat);
        group.add(mesh);
        group.position.set(x, 1, z);
        group.userData = { mesh, type: "speed" };
        scene.add(group);
        healthPacks.push(group); // Using same array for simplicity
      }

      // === Input ===
      const input = {
        keys: {},
        mouse: { x: 0, y: 0, down: false },
      };

      addEventListener("keydown", (e) => (input.keys[e.code] = true));
      addEventListener("keyup", (e) => (input.keys[e.code] = false));
      addEventListener("mousemove", (e) => {
        if (started && document.pointerLockElement) {
          camera3rd.angleY -= e.movementX * camera3rd.sensitivity;
        }
        input.mouse.x = (e.clientX / innerWidth) * 2 - 1;
        input.mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      });
      addEventListener("mousedown", () => (input.mouse.down = true));
      addEventListener("mouseup", () => (input.mouse.down = false));

      // === Player Actions ===
      function playerAttack() {
        if (gameState.attackCooldown > 0) return;

        gameState.attackCooldown = gameState.timeSlowActive ? 0.15 : 0.3;
        audio.playAttack();

        // Sword swing animation
        const sword = playerGroup.children[1];
        sword.rotation.z = -1.5;
        setTimeout(() => (sword.rotation.z = -0.3), 150);

        let hitCount = 0;
        let totalDamage = 25;

        // Berserker mode triple damage
        if (gameState.berserkerMode) {
          totalDamage *= 3;
        }

        // Combo multiplier
        if (gameState.combo > 0) {
          totalDamage += gameState.combo * 5;
          sword.material.emissiveIntensity = 0.5 + gameState.combo * 0.1;
        }

        // Check hit enemies
        enemies.forEach((enemy) => {
          const dist = enemy.group.position.distanceTo(playerGroup.position);
          if (dist < (gameState.rage > 50 ? 3 : 2)) {
            hitCount++;
            gameState.combo++;
            gameState.comboTimer = 100; // 100 frames
            gameState.rage = Math.min(gameState.maxRage, gameState.rage + 10);

            enemy.takeDamage(totalDamage);
            createCombatText(
              enemy.group.position,
              `${totalDamage}${gameState.combo > 1 ? ` x${gameState.combo}` : ""}`,
              "#ffdd00",
            );
            createParticles(
              enemy.group.position,
              gameState.combo > 5 ? 0xff0000 : 0xffdd00,
              8 + gameState.combo,
            );

            // Rage mode screen shake
            if (gameState.rage > 50) {
              camera.position.x += (Math.random() - 0.5) * 0.5;
              camera.position.z += (Math.random() - 0.5) * 0.5;
            }
          }
        });

        // Special combo effects
        if (gameState.combo >= 10) {
          triggerEarthquake();
        } else if (gameState.combo >= 5) {
          triggerTimeSlow();
        }

        if (hitCount === 0) {
          gameState.combo = 0; // Reset combo on miss
        }
      }

      function triggerTimeSlow() {
        if (gameState.timeSlowActive) return;
        gameState.timeSlowActive = true;
        showPowerup("‚è±Ô∏è TIME SLOW! ‚è±Ô∏è");

        // Visual effect
        scene.background = new THREE.Color(0x000040);

        setTimeout(() => {
          gameState.timeSlowActive = false;
          scene.background = new THREE.Color(0x0a0e27);
        }, 3000);
      }

      function triggerEarthquake() {
        if (gameState.earthquakeActive) return;
        gameState.earthquakeActive = true;
        showPowerup("üåç EARTHQUAKE! üåç");
        audio.playEarthquake();

        // Damage all enemies
        enemies.forEach((enemy) => {
          enemy.takeDamage(50);
          createParticles(enemy.group.position, 0xff4400, 15);
        });

        // Screen shake
        const originalPos = camera.position.clone();
        let shakeTime = 60;
        const shakeInterval = setInterval(() => {
          camera.position.x = originalPos.x + (Math.random() - 0.5) * 2;
          camera.position.y = originalPos.y + (Math.random() - 0.5) * 2;
          camera.position.z = originalPos.z + (Math.random() - 0.5) * 2;

          shakeTime--;
          if (shakeTime <= 0) {
            clearInterval(shakeInterval);
            camera.position.copy(originalPos);
            gameState.earthquakeActive = false;
          }
        }, 16);
      }

      function playerDash() {
        if (gameState.dashCooldown > 0) return;

        gameState.dashCooldown = gameState.rage > 75 ? 1 : 2;
        gameState.invulnerable = gameState.rage > 75 ? 1 : 0.5;
        audio.playDash();

        // Dash in camera direction
        const forward = new THREE.Vector3(
          Math.sin(camera3rd.angleY),
          0,
          Math.cos(camera3rd.angleY),
        );
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

        const moveDir = new THREE.Vector3();
        if (input.keys["KeyW"] || input.keys["ArrowUp"]) moveDir.add(forward);
        if (input.keys["KeyS"] || input.keys["ArrowDown"]) moveDir.sub(forward);
        if (input.keys["KeyD"] || input.keys["ArrowRight"]) moveDir.add(right);
        if (input.keys["KeyA"] || input.keys["ArrowLeft"]) moveDir.sub(right);

        if (moveDir.length() === 0) moveDir.copy(forward); // Dash forward by default
        moveDir.normalize();

        const dashDistance = gameState.rage > 50 ? 5 : 3;
        playerGroup.position.addScaledVector(moveDir, dashDistance);

        // Dash attack - damage enemies you dash through
        enemies.forEach((enemy) => {
          const dist = enemy.group.position.distanceTo(playerGroup.position);
          if (dist < 2) {
            enemy.takeDamage(35);
            createCombatText(enemy.group.position, "DASH ATTACK!", "#00ffff");
            createParticles(enemy.group.position, 0x00ffff, 12);
            gameState.combo++;
          }
        });

        createParticles(playerGroup.position, gameState.rage > 50 ? 0xff6600 : 0x64d4ff, 15);
      }

      function triggerBerserkerMode() {
        if (gameState.rage < 50) return;
        gameState.rage = 0;

        showPowerup("üî• BERSERKER RAGE! üî•");
        audio.playBerserker();

        // Triple damage and speed for 5 seconds
        gameState.berserkerMode = true;
        playerMesh.material.emissive.setHex(0xff0000);
        playerMesh.material.emissiveIntensity = 1;

        // Screen effect
        scene.background = new THREE.Color(0x400000);

        setTimeout(() => {
          gameState.berserkerMode = false;
          playerMesh.material.emissive.setHex(0x0066ff);
          playerMesh.material.emissiveIntensity = 0.2;
          scene.background = new THREE.Color(0x0a0e27);
          showPowerup("Berserker mode ended!");
        }, 5000);
      }

      function triggerLightningStrike() {
        if (gameState.combo < 3) return;
        gameState.combo = 0;

        showPowerup("‚ö° LIGHTNING STRIKE! ‚ö°");
        audio.playLightning();

        // Find closest enemy and nuke it
        let closestEnemy = null;
        let closestDist = Infinity;

        enemies.forEach((enemy) => {
          const dist = enemy.group.position.distanceTo(playerGroup.position);
          if (dist < closestDist) {
            closestEnemy = enemy;
            closestDist = dist;
          }
        });

        if (closestEnemy) {
          // Lightning effect
          createParticles(closestEnemy.group.position, 0xffffff, 30);
          createParticles(playerGroup.position, 0x00ffff, 20);

          // Chain lightning to nearby enemies
          enemies.forEach((enemy) => {
            const dist = enemy.group.position.distanceTo(closestEnemy.group.position);
            if (dist < 5) {
              enemy.takeDamage(100);
              createParticles(enemy.group.position, 0xffffff, 15);
              createCombatText(enemy.group.position, "LIGHTNING!", "#ffffff");
            }
          });

          // Screen flash
          scene.background = new THREE.Color(0xffffff);
          setTimeout(() => (scene.background = new THREE.Color(0x0a0e27)), 100);
        }
      }

      // === UI Functions ===
      function updateUI() {
        document.getElementById("healthText").textContent = `${Math.ceil(gameState.health)}/${
          gameState.maxHealth
        }`;
        document.getElementById("health").style.width = `${
          (gameState.health / gameState.maxHealth) * 100
        }%`;

        // Change health bar color based on rage
        const healthBar = document.getElementById("health");
        if (gameState.rage > 75) {
          healthBar.style.background = "linear-gradient(90deg, #ff0000, #ff6600)";
        } else if (gameState.rage > 50) {
          healthBar.style.background = "linear-gradient(90deg, #ff6600, #ffaa00)";
        } else {
          healthBar.style.background = "linear-gradient(90deg, #ff6b6b, #ff8e8e)";
        }

        document.getElementById("keys").textContent = gameState.keysCollected;
        document.getElementById("door").textContent = gameState.doorOpen ? "üîì Open!" : "üîí Locked";
        document.getElementById("enemies").textContent = enemies.length;
        document.getElementById("scoreValue").textContent = gameState.score;
        document.getElementById("wave").textContent = gameState.wave;

        // Show combo and rage if active
        if (gameState.combo > 0) {
          createCombatText(playerGroup.position, `${gameState.combo}x COMBO!`, "#ffffff");
        }
      }

      function takeDamage(amount) {
        gameState.health = Math.max(0, gameState.health - amount);
        updateUI();

        // Screen flash
        const flash = document.createElement("div");
        flash.className = "damage-flash";
        document.body.appendChild(flash);
        setTimeout(() => flash.remove(), 300);

        // Camera shake
        const originalPos = camera.position.clone();
        camera.position.x += (Math.random() - 0.5) * 0.5;
        camera.position.y += (Math.random() - 0.5) * 0.5;
        setTimeout(() => camera.position.copy(originalPos), 100);

        if (gameState.health <= 0) {
          gameOver();
        }
      }

      function createCombatText(position, text, color) {
        const elem = document.createElement("div");
        elem.className = "combat-text";
        elem.textContent = text;
        elem.style.color = color;

        const vector = position.clone();
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * innerHeight;

        elem.style.left = x + "px";
        elem.style.top = y + "px";
        document.body.appendChild(elem);

        setTimeout(() => elem.remove(), 1000);
      }

      function showPowerup(text) {
        const elem = document.getElementById("powerup");
        elem.textContent = text;
        elem.classList.add("show");
        setTimeout(() => elem.classList.remove("show"), 2000);
      }

      // === Game Over ===
      function gameOver() {
        const msg = document.getElementById("msg");
        msg.style.display = "grid";
        msg.innerHTML = `
        <div class="card">
          <h1>üíÄ GAME OVER üíÄ</h1>
          <p>You survived ${gameState.wave} wave${gameState.wave > 1 ? "s" : ""}!</p>
          <p>Final Score: <strong>${gameState.score}</strong></p>
          <p>Enemies Defeated: <strong>${gameState.enemiesKilled}</strong></p>
          <button class="btn" onclick="location.reload()">RETRY</button>
        </div>
      `;
      }

      function victory() {
        gameState.score += 1000;
        audio.playWin();

        // Next wave
        gameState.wave++;
        gameState.health = Math.min(gameState.maxHealth, gameState.health + 50);
        gameState.keysCollected = 0;
        gameState.doorOpen = false;

        // Respawn keys
        keys.forEach((k) => (k.visible = true));

        // Spawn more enemies
        for (let i = 0; i < gameState.wave + 1; i++) {
          const x = (Math.random() - 0.5) * 20;
          const z = (Math.random() - 0.5) * 20;
          new Enemy(x, z, i % 3 === 0 ? "heavy" : "basic");
        }

        doorMesh.material.emissiveIntensity = 0;
        showPowerup(`üéâ WAVE ${gameState.wave} üéâ`);
        updateUI();
      }

      // === Camera System ===
      const camera3rd = {
        distance: 10,
        height: 10,
        angleY: 0,
        sensitivity: 0.003,
        target: new THREE.Vector3(),
        position: new THREE.Vector3(),
      };

      // === Game Loop ===
      let lastTime = performance.now();
      let started = false;
      let fpsCounter = 0,
        fpsTime = 0;
      const clock = new THREE.Clock();

      function update(dt) {
        if (!started) return;

        // Debug: log once when game starts
        if (!window.gameLoopLogged) {
          console.log("Game loop is running!");
          window.gameLoopLogged = true;
        }

        // Player movement relative to camera with speed boost
        let baseSpeed = 5;
        if (gameState.powerups.includes("speed")) baseSpeed = 7;
        if (gameState.berserkerMode) baseSpeed = 10; // INSANE speed in berserker mode
        const moveSpeed =
          input.keys["ShiftLeft"] || input.keys["ShiftRight"] ? baseSpeed * 1.6 : baseSpeed;
        const forward = new THREE.Vector3(
          Math.sin(camera3rd.angleY),
          0,
          Math.cos(camera3rd.angleY),
        );
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

        const moveDir = new THREE.Vector3();
        if (input.keys["KeyW"] || input.keys["ArrowUp"]) moveDir.add(forward);
        if (input.keys["KeyS"] || input.keys["ArrowDown"]) moveDir.sub(forward);
        if (input.keys["KeyD"] || input.keys["ArrowRight"]) moveDir.add(right);
        if (input.keys["KeyA"] || input.keys["ArrowLeft"]) moveDir.sub(right);
        moveDir.normalize();

        const nextPos = playerGroup.position.clone().addScaledVector(moveDir, moveSpeed * dt);

        // Wall collision
        let blocked = false;
        for (const wall of walls) {
          const dx = Math.abs(nextPos.x - wall.position.x) - (T / 2 + 0.5);
          const dz = Math.abs(nextPos.z - wall.position.z) - (T / 2 + 0.5);
          if (dx < 0 && dz < 0) {
            blocked = true;
            break;
          }
        }

        if (!blocked) {
          playerGroup.position.copy(nextPos);
        }

        // Player rotation
        if (moveDir.lengthSq() > 0) {
          playerGroup.rotation.y = Math.atan2(moveDir.x, moveDir.z);
        }

        // Simple higher 3rd person camera
        camera3rd.target.lerp(playerGroup.position, 0.1);

        // Position camera higher and further back
        const camOffset = new THREE.Vector3(
          -Math.sin(camera3rd.angleY) * camera3rd.distance,
          camera3rd.height,
          -Math.cos(camera3rd.angleY) * camera3rd.distance,
        );

        camera3rd.position.copy(camera3rd.target).add(camOffset);
        camera.position.lerp(camera3rd.position, 0.08);
        camera.lookAt(camera3rd.target.x, camera3rd.target.y + 3, camera3rd.target.z);

        // Update cooldowns and timers
        gameState.attackCooldown = Math.max(0, gameState.attackCooldown - dt);
        gameState.dashCooldown = Math.max(0, gameState.dashCooldown - dt);
        gameState.invulnerable = Math.max(0, gameState.invulnerable - dt);

        // Combo timer
        if (gameState.comboTimer > 0) {
          gameState.comboTimer--;
        } else {
          gameState.combo = 0;
        }

        // Rage decay
        gameState.rage = Math.max(0, gameState.rage - 0.2);

        // Time slow effect on enemies
        const timeMultiplier = gameState.timeSlowActive ? 0.3 : 1;

        // Player flashing when invulnerable
        if (gameState.invulnerable > 0) {
          playerMesh.material.opacity = Math.sin(Date.now() * 0.02) * 0.5 + 0.5;
        } else {
          playerMesh.material.opacity = 1;
        }

        // Actions
        if (input.mouse.down) playerAttack();
        if (input.keys["Space"]) playerDash();
        if (input.keys["KeyQ"]) triggerBerserkerMode();
        if (input.keys["KeyE"]) triggerLightningStrike();
        if (input.keys["KeyR"]) {
          playerGroup.position.set(0, 1.2, 0); // Center of map, not in wall
          gameState.health = gameState.maxHealth;
          updateUI();
        }

        // Emergency teleport keys
        if (input.keys["Digit1"]) playerGroup.position.set(0, 1.2, 0);
        if (input.keys["Digit2"]) playerGroup.position.set(5, 1.2, 5);
        if (input.keys["Digit3"]) playerGroup.position.set(-5, 1.2, -5);

        // Update enemies with time multiplier
        enemies.forEach((enemy) => enemy.update(dt * timeMultiplier, playerGroup.position));

        // Collect keys
        for (let i = keys.length - 1; i >= 0; i--) {
          const key = keys[i];
          if (!key.visible) continue;

          // Rotate and float
          key.rotation.y += dt * 2;
          key.position.y = 1.5 + Math.sin(Date.now() * 0.002) * 0.2;
          key.userData.glow.material.opacity = 0.2 + Math.sin(Date.now() * 0.003) * 0.1;

          // Collect
          if (key.position.distanceTo(playerGroup.position) < 1) {
            key.visible = false;
            gameState.keysCollected++;
            gameState.score += 50;
            audio.playPickup();
            createParticles(key.position, 0xffd700, 15);

            if (gameState.keysCollected >= 5) {
              gameState.doorOpen = true;
              doorMesh.material.emissiveIntensity = 0.8;
              showPowerup("üîì DOOR UNLOCKED!");
            }

            updateUI();
          }
        }

        // Collect health packs
        for (let i = healthPacks.length - 1; i >= 0; i--) {
          const pack = healthPacks[i];
          pack.rotation.y += dt * 3;
          pack.userData.mesh.position.y = Math.sin(Date.now() * 0.003) * 0.1;

          if (pack.position.distanceTo(playerGroup.position) < 1) {
            const type = pack.userData.type;
            if (type === "health") {
              gameState.health = Math.min(gameState.maxHealth, gameState.health + 25);
              createCombatText(pack.position, "+25 HP", "#00ff00");
              createParticles(pack.position, 0x00ff00, 10);
            } else if (type === "speed") {
              if (!gameState.powerups.includes("speed")) {
                gameState.powerups.push("speed");
                setTimeout(() => {
                  gameState.powerups = gameState.powerups.filter((p) => p !== "speed");
                  showPowerup("Speed boost ended!");
                }, 10000); // 10 second speed boost
              }
              createCombatText(pack.position, "SPEED BOOST!", "#00ffff");
              createParticles(pack.position, 0x00ffff, 15);
              showPowerup("‚ö° SPEED BOOST! ‚ö°");
            }

            scene.remove(pack);
            healthPacks.splice(i, 1);
            audio.playPickup();
            updateUI();
          }
        }

        // Check door
        if (gameState.doorOpen && doorGroup.position.distanceTo(playerGroup.position) < 1.5) {
          victory();
        }

        // Update particles
        updateParticles(dt);

        // Animate lights
        pointLight1.position.x = Math.sin(clock.getElapsedTime() * 0.5) * 10;
        pointLight1.position.z = Math.cos(clock.getElapsedTime() * 0.5) * 10;
        pointLight2.position.x = Math.sin(clock.getElapsedTime() * 0.7 + Math.PI) * 10;
        pointLight2.position.z = Math.cos(clock.getElapsedTime() * 0.7 + Math.PI) * 10;
      }

      function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        const dt = Math.min(0.05, (now - lastTime) / 1000);
        lastTime = now;

        update(dt);
        renderer.render(scene, camera);

        // FPS counter
        fpsCounter++;
        fpsTime += dt;
        if (fpsTime > 0.5) {
          document.getElementById("fpsv").textContent = Math.round(fpsCounter / fpsTime);
          fpsCounter = 0;
          fpsTime = 0;
        }
      }

      // === Start Game ===
      const startBtn = document.getElementById("start");
      console.log("Start button element:", startBtn);
      console.log("All buttons:", document.querySelectorAll("button"));

      if (!startBtn) {
        console.error("Start button not found!");
      } else {
        console.log("Attaching click handler to start button");
        startBtn.onclick = async () => {
          console.log("Start button clicked!");
          try {
            started = true;
            document.getElementById("msg").style.display = "none";
            console.log("Starting Tone...");
            await Tone.start();
            console.log("Initializing audio...");
            audio.init();
            console.log("Updating UI...");
            updateUI();
            // Lock pointer for mouse look
            renderer.domElement.requestPointerLock();
            console.log("Game started successfully!");
          } catch (error) {
            console.error("Error starting game:", error);
          }
        };

        // === Resize Handler ===
        addEventListener("resize", () => {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
        });

        animate();
      } // end else
    </script>
  </body>
</html>
